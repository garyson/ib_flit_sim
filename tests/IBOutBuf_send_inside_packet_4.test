%description:
Verifies that the output buffer does not send a flow control packet
while in the INSIDE_PACKET state.

%inifile: omnetpp.ini

Test.obuf.size = 36
Test.obuf.width = 4
Test.obuf.maxVL = 0

%file: test.ned

import ib_model.IBOutBuf;
import ib_model.IB4XQDRWire;

network Test
{
    submodules:
        mock: Mock;
        obuf: IBOutBuf;

    connections:
        mock.out --> obuf.in;
        mock.txCred --> obuf.rxCred;
        mock.in <-- IB4XQDRWire <-- obuf.out;
        mock.free <-- obuf.free;
};

%file: mock.ned

simple Mock
{
    gates:
        output out;
        output txCred;
        input in;
        input free;
};

%file: mock.cc

#include <omnetpp.h>
#include "../lib/VLState.h"
#include "ib_m.h"

namespace @TESTNAME@ {

using namespace omnetpp;

class Mock;

class MockVLState : public VLState {
public:
    MockVLState(unsigned int id, Mock *mock);
protected:
    virtual void onFirstFCP(IBFlowControl *msg) override;
private:
    Mock *mock;

    static const unsigned int initExpectedFCPCount = 2;
};

class Mock : public cSimpleModule {
public:
    Mock();
    virtual void initialize() override;
    virtual void handleMessage(cMessage *msg) override;
    virtual void finish() override;

    void sendMessages();

private:
    void handleFlowControl(IBFlowControl *msg);
    void handleData(IBDataMsg *msg);

    const simtime_t initTime = SimTime::parse("1us");
    const simtime_t incrTime = SimTime::parse("1ns");
    MockVLState vl;
    cMessage *endMsg;
    unsigned int dataCount;
};

MockVLState::MockVLState(unsigned int id, Mock *mock)
    : VLState(id, initExpectedFCPCount), mock(mock)
{
}

void MockVLState::onFirstFCP(IBFlowControl *msg)
{
    mock->sendMessages();
}

Define_Module(Mock);

Mock::Mock() : vl(0, this)
{
}

void Mock::initialize()
{
    dataCount = 0;

    endMsg = new cMessage();
    scheduleAt(SimTime::parse("1ms"), endMsg);
}

void Mock::finish()
{
    vl.finish();
}

void Mock::sendMessages()
{
    IBDataMsg *outMsg = new IBDataMsg("TEST", IB_DATA_MSG);
    outMsg->setName("TEST");
    outMsg->setVL(0);
    outMsg->setAppIdx(0);
    outMsg->setMsgIdx(0);
    outMsg->setMsgLen(1);
    outMsg->setPktIdx(0);
    outMsg->setPacketId(0);
    outMsg->setPacketSn(0);
    outMsg->setFlitSn(0);
    outMsg->setPacketLength(2);
    outMsg->setPacketLengthBytes(128);
    outMsg->setDstLid(2);
    outMsg->setSrcLid(1);
    outMsg->setSL(0);
    outMsg->setUseStatic(1);
    outMsg->setBeforeAnySwitch(true);
    /* cPacket field required for valid transmission delay */
    outMsg->setByteLength(64);

    sendDelayed(outMsg, initTime, "out");

}

void Mock::handleFlowControl(IBFlowControl *msg)
{
    /* Work around fact that message VL is currently defined as a signed
     * type */
    if (msg->getVL() != 0) {
        std::cout << "ERROR: Got invalid VL " << msg->getVL();
        return;
    }
    vl.handleRecvFCP(msg);
}

void Mock::handleData(IBDataMsg *msg)
{
    ++dataCount;
    if (dataCount == 1) {
        vl.sendCreditUpdate(this, "txCred", 0);

        IBDataMsg *outMsg = new IBDataMsg("TEST-2", IB_DATA_MSG);
        outMsg->setVL(0);
        outMsg->setAppIdx(0);
        outMsg->setMsgIdx(0);
        outMsg->setMsgLen(1);
        outMsg->setPktIdx(0);
        outMsg->setPacketId(0);
        outMsg->setPacketSn(0);
        outMsg->setFlitSn(1);
        outMsg->setPacketLength(2);
        outMsg->setPacketLengthBytes(128);
        outMsg->setDstLid(2);
        outMsg->setSrcLid(1);
        outMsg->setSL(0);
        outMsg->setUseStatic(1);
        outMsg->setBeforeAnySwitch(true);
        /* cPacket field required for valid transmission delay */
        outMsg->setByteLength(64);

        sendDelayed(outMsg, incrTime, "out");
    } else if (dataCount == 2) {
        vl.acceptFCP();
    } else {
        std::cout << "Error did not expect " << dataCount << " data messages\n";
    }
}

void Mock::handleMessage(cMessage *msg)
{
    if (msg == endMsg) {
        /* Special message to end simulation */
        delete msg;
        this->endSimulation();
    }

    std::cout << "Got message at time " << simTime() << "\n";
    if (msg->getKind() == IB_FLOWCTRL_MSG) {
        handleFlowControl((IBFlowControl *)msg);
    } else if (msg->getKind() == IB_DATA_MSG) {
        handleData((IBDataMsg *)msg);
    } else if (msg->getKind() == IB_FREE_MSG) {
        /* ignore */
    } else {
        std::cout << "ERROR: Wrong message kind; expected IB_DATA_MSG or IB_FLOWCTRL_MSG got "
		  << cEnum::get("IB_MSGS")->getStringFor(msg->getKind())
	          << "\n";
    }
    delete msg;
}

}


%not-contains: stdout
ERROR
