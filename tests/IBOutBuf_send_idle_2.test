// tests/IBOutBuf_send_idle_2.test
//
// InfiniBand FLIT (Credit) Level OMNet++ Simulation Model
//
// Copyright (c) 2015-2016 University of New Hampshire InterOperability Laboratory
//
// This software is available to you under the terms of the GNU
// General Public License (GPL) Version 2, available from the file
// COPYING in the main directory of this source tree.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
// BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

%description:
Verifies that the output buffer sends a flow control packet when it gets
a credit update in the idle state.

%inifile: omnetpp.ini

Test.obuf.size = 36
Test.obuf.width = 4
Test.obuf.maxVL = 0

%file: test.ned

import ib_model.IBOutBuf;
import ib_model.IB4XQDRWire;

network Test
{
    submodules:
        mock: Mock;
        obuf: IBOutBuf;

    connections:
        mock.out --> ned.IdealChannel --> obuf.in;
        mock.txCred --> ned.IdealChannel --> obuf.rxCred;
        mock.in <-- IB4XQDRWire <-- obuf.out;
        mock.free <-- ned.IdealChannel <-- obuf.free;
};

%file: mock.ned

simple Mock
{
    gates:
        output out;
        output txCred;
        input in;
        input free;
};

%file: mock.cc

#include <omnetpp.h>
#include "ib_m.h"

namespace @TESTNAME@ {

using namespace omnetpp;

class Mock : public cSimpleModule {
public:
    virtual void initialize() override;
    virtual void handleMessage(cMessage *msg) override;

private:
    void handleFlowControl(IBFlowControl *msg);
    cMessage *endMsg;
    simtime_t initTime;
    unsigned int flowControlCount = 0;
    unsigned int latestFCTBS;
    unsigned int latestFCCL;
    unsigned int expectedFCCL = 10;
};

Define_Module(Mock);

void Mock::initialize()
{
    flowControlCount = 0;
    expectedFCCL = 10;
    initTime = SimTime::parse("1us");

    endMsg = new cMessage();
    scheduleAt(SimTime::parse("1ms"), endMsg);

    IBRxCredMsg *credMsg = new IBRxCredMsg("rxcred-test-msg", IB_RXCRED_MSG);
    credMsg->setVL(0);
    credMsg->setFCCL(expectedFCCL);
    sendDelayed(credMsg, initTime, "out");
}

void Mock::handleFlowControl(IBFlowControl *msg)
{
    flowControlCount++;

    std::cout << "Was flow control message #" << flowControlCount << '\n';
    latestFCTBS = msg->getFCTBS();
    latestFCCL = msg->getFCCL();

    if (flowControlCount == 2 && latestFCCL != expectedFCCL) {
        std::cout << "ERROR: Expected FCCL " << expectedFCCL
                  << "got " << latestFCCL << '\n';
    }
}

void Mock::handleMessage(cMessage *msg)
{
    if (msg == endMsg) {
        /* Special message to end simulation */
        if (flowControlCount < 2) {
            std::cout << "Expected 2 flow control messages; got "
                      << flowControlCount << '\n';
        }
        delete msg;
        this->endSimulation();
    }

    std::cout << "Got message at time " << simTime() << "\n";
    switch (msg->getKind()) {
    case IB_FLOWCTRL_MSG:
        handleFlowControl((IBFlowControl *)msg);
        break;
    default:
        std::cout << "ERROR: Unexpected message kind "
		  << cEnum::get("IB_MSGS")->getStringFor(msg->getKind())
	          << "\n";
    }

    delete msg;
}

}


%not-contains: stdout
ERROR
