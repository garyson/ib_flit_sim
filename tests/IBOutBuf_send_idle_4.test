%description:
Verifies that the output buffer sends a flow control packet for each
virtual lane when it gets out of order credit updates in the idle state.

%inifile: omnetpp.ini

Test.obuf.size = 36
Test.obuf.width = 4
Test.obuf.maxVL = 1

%file: test.ned

import ib_model.IBOutBuf;
import ib_model.IB4XQDRWire;

network Test
{
    submodules:
        mock: Mock;
        obuf: IBOutBuf;

    connections:
        mock.out --> ned.IdealChannel --> obuf.in;
        mock.txCred --> ned.IdealChannel --> obuf.rxCred;
        mock.in <-- IB4XQDRWire <-- obuf.out;
        mock.free <-- ned.IdealChannel <-- obuf.free;
};

%file: mock.ned

simple Mock
{
    gates:
        output out;
        output txCred;
        input in;
        input free;
};

%file: mock.cc

#include <vector>
#include <omnetpp.h>
#include "ib_m.h"
#include "../lib/VLState.h"

namespace @TESTNAME@ {

template <typename T>
bool inRange(T value, T min, T max)
{
    return min <= value && value <= max;
}

class Mock;

class MockVLState : public VLState {
public:
    MockVLState(unsigned int id, Mock *mock);
protected:
    virtual void onFirstFCP(IBFlowControl *msg) override;
private:
    Mock *mock;

    static const unsigned int initExpectedFCPCount = 2;
};

class Mock : public cSimpleModule {
public:
    Mock();
    virtual void initialize() override;
    virtual void handleMessage(cMessage *msg) override;
    virtual void finish() override;

    void sendCreditUpdates();

    static const unsigned int maxVL = 1;

private:
    void handleFlowControl(IBFlowControl *msg);

    const simtime_t initTime = SimTime::parse("1us");
    cMessage *endMsg;
    std::vector<MockVLState> vl;
};

MockVLState::MockVLState(unsigned int id, Mock *mock)
    : VLState(id, initExpectedFCPCount), mock(mock)
{
}

void MockVLState::onFirstFCP(IBFlowControl *msg)
{
    if (id == Mock::maxVL) {
        mock->sendCreditUpdates();
    }
}

Define_Module(Mock);

Mock::Mock()
{
    for (unsigned int vlid = 0; vlid <= maxVL; ++vlid) {
        /* Directly put a VLState into the vector at the right position
         * with the right VL ID */
        vl.emplace_back(vlid, this);
    }
}

void Mock::initialize()
{
    endMsg = new cMessage();
    scheduleAt(SimTime::parse("1ms"), endMsg);
}

void Mock::sendCreditUpdates()
{
    /* static const unsigned int nextFCCL = 10; */

    vl[1].sendCreditUpdate(this, "out", initTime);
    vl[1].acceptFCP();

    vl[0].sendCreditUpdate(this, "out", initTime + SimTime::parse("1ns"));
    vl[0].acceptFCP();
}

void Mock::finish()
{
    for (unsigned int i = 0; i <= maxVL; ++i) {
        vl[i].finish();
    }
}

void Mock::handleFlowControl(IBFlowControl *msg)
{
    /* Work around fact that message VL is currently defined as a signed
     * type */
    if (!inRange((int)msg->getVL(), 0, (int)maxVL)) {
        std::cout << "ERROR: Got invalid VL " << msg->getVL();
        return;
    }
    unsigned int msgVL = msg->getVL();
    vl[msgVL].handleRecvFCP(msg);
}

void Mock::handleMessage(cMessage *msg)
{
    if (msg == endMsg) {
        /* Special message to end simulation */
        delete msg;
        this->endSimulation();
    }

    switch (msg->getKind()) {
    case IB_FLOWCTRL_MSG:
        handleFlowControl((IBFlowControl *)msg);
        break;
    default:
        std::cout << "ERROR: Unexpected message kind "
                  << cEnum::get("IB_MSGS")->getStringFor(msg->getKind())
                  << "\n";
    }

    delete msg;
}

}


%not-contains: stdout
ERROR
